# Коллоквиум №3: Анализ поведенческих шаблонов проектирования (Вариант 2)

## Цели исследования

1. Изучить три ключевых поведенческих паттерна:
   - Состояние (State)
   - Посредник (Mediator)
   - Наблюдатель (Observer)

2. Проанализировать:
   - Понятие дизайна ПО
   - Влияние многопоточности на проектирование системы

3. Для каждого паттерна рассмотреть:
   - Проблемное пространство
   - Предлагаемое решение
   - Аспекты инкапсуляции
   - Применение принципа разделения ответственности
   - Ортогональность компонентов
   - Особенности работы в многопоточной среде

---

## 1. Паттерн "Состояние" (`state.cpp`)

### Контекст проблемы
Объект демонстрирует различное поведение в зависимости от внутреннего состояния. Наивная реализация через условные операторы приводит к:
- Трудностям поддержки
- Нарушению OCP (принципа открытости/закрытости)
- Высокой цикломатической сложности

### Архитектурное решение
1. Каждое состояние инкапсулируется в отдельном классе
2. Контекст делегирует обработку текущему объекту-состоянию
3. Переходы между состояниями могут быть реализованы как:
   - Внутри классов состояний
   - В отдельном машине состояний
   - Через внешние триггеры

### Ключевые аспекты:
- **Инкапсуляция**: Детали реализации состояний скрыты за общим интерфейсом
- **Разделение**: Каждое состояние - независимый модуль
- **Ортогональность**: Новые состояния добавляются без модификации существующего кода
- **Многопоточность**: Требуется:
  - Атомарные переходы между состояниями
  - Защита shared state (например, через std::atomic)
  - Возможность блокировки контекста при критических операциях

---

## 2. Паттерн "Посредник" (`mediator.cpp`)

### Проблема связности
При прямом взаимодействии N компонентов возникает:
- O(N²) связей
- Жёсткие зависимости
- Сложность рефакторинга

### Централизованное управление
1. Посредник становится единой точкой взаимодействия
2. Компоненты общаются только через медиатор
3. Логика маршрутизации изолирована в одном месте

### Преимущества:
- **Инкапсуляция**: Протокол взаимодействия скрыт внутри медиатора
- **Разделение**: Компоненты не знают о существовании друг друга
- **Ортогональность**: Можно изменять схему взаимодействия без модификации компонентов
- **Многопоточность**: Медиатор может:
  - Обеспечивать thread-safe коммуникацию
  - Реализовывать очереди сообщений
  - Выполнять балансировку нагрузки

---

## 3. Паттерн "Наблюдатель" (`observer.cpp`)

### Проблема синхронизации
Как эффективно уведомлять множество объектов об изменениях без создания жёстких зависимостей?

### Реализация pub-sub
1. Субъект поддерживает список подписчиков
2. Уведомления рассылаются через абстрактный интерфейс
3. Подписка/отписка динамически изменяемы

### Особенности реализации:
- **Инкапсуляция**: Субъект не зависит от конкретных наблюдателей
- **Разделение**: Наблюдатели могут существовать в разных модулях системы
- **Ортогональность**: Разные стратегии обработки событий
- **Многопоточность**: Важные аспекты:
  - Потокобезопасность списка подписчиков
  - Варианты доставки (синхронный/асинхронный)
  - Обработка "устаревших" событий

### Пример из Qt:
Механизм сигналов/слотов - расширенная реализация Observer:
- Автоматическая обработка потока событий
- Типобезопасные соединения
- Поддержка асинхронного вызова

---

## 4. Дизайн ПО: концепция и эволюция

### Определение
Дизайн ПО - это:
1. Процесс создания архитектурных решений
2. Организация взаимодействия компонентов
3. Выбор оптимальных абстракций
4. Обеспечение критериев качества (SOLID, GRASP)

### Многопоточность и дизайн
1. **Влияние на структуру**:
   - Появление новых сущностей (пулы потоков, очереди)
   - Необходимость управления жизненным циклом

2. **Проблемы проектирования**:
   - Состояние гонки
   - Взаимоблокировки
   - Проблемы видимости изменений

3. **Стратегии решения**:
   - Immutable объекты
   - Thread-local storage
   - Lock-free алгоритмы
   - Акторная модель
